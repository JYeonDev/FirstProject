<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        body{
            height: 100vh;
            margin: 20px;
            display: flex;
            justify-content: space-evenly;
            align-items: center;
        }
        div{
            width: 300px;
            height: 300px;
            background-color: teal;
        }
        #second{
            background-color: wheat;
        }
    </style>
</head>
<body>
    <div></div>
    <div id="second"></div>
    <div></div>
    <!-- block 속성은 자신 옆에 아무것도 오지 못한다.
         inline 속성은 자신 옆에 다른 것이 올수있다.
         ('같은 줄에 위치할수 있다'는 뜻)
         대부분의 속성은 block 속성을 띄고 있기 때문에
         inline 속성을 기억하는게 쉽다.
         ex) span , a , image
    -->

    <!-- 
        inline 속성은 높이와 너비를 가질 수 없다.
        block 속성은 높이와 너비를 가질 수 있다.
     -->
     <!-- 
        방향 설정 없이 margin 하나를 주면 사방에 전부 다 적용된다.
        두 개를 줄 경우 상하, 좌우 이다.
        네 개를 줄 경우 시계방향 순으로 적용된다. (상 우 하 좌)
        Collapsing margin 현상 (상하에서만 발생함)
        div margin이 body margin과 같을 때 발생하고 body 와 div margin은 둘중 큰값의 margin으로 취급된다.
      -->

      <!-- 
          margin은 박스의 경계로 부터 바깥에 있는 공간
          padding은 박스의 경계로 부터 안쪽에 있는 공간
          아이디선택자 : #
       -->
       <!-- 
           border : 사이즈(px) style color;
           border는 block 과 inline 모두에 적용한다.
           * 전체 선택자
           html,css 는 위에서 아래로 적용한다.
           ex) body{color : white;}
               body{color : black;} <--- 아래가 적용됨. 
        -->
        <!-- 
            inline은 높이와 너비를 가질수없다 그래서 위 아래로 margin을 가질수 없다. padding은 가능
            id 는 한 요소에만 사용 가능하지만 class는 여러 요소에 사용 가능하다.
            ex)<span id="tomato"></span>
               <span id="tomato"></span> <---- 사용 불가능
               
               <span class="tomato"></span>
               <span class="tomato"></span> <----- 중복해서 사용가능

            또, id 는 하나의 id만 생성이 가능하지만 class는 여러 class 가 생성 가능하다.(띄워쓰기를 통해 사용)
            ex)<span id="tomato melon"></span> <----- 불가능

               <span class="tomato melon"></span> <----- 한 요소에 class 여러개 사용가능
               선택자로 잡을 때 .tomato .melon 따로 선택 가능

         -->

         <!-- 
             block은 옆에 아무것도 올 수 없음

            ㅡ> inline : wdt, hgt 무시돼서 무언가 추가하지 않는 이상 아무것도 안보임
            ㅡ> inline-block : 위 문제를 해결할 수 있어서 좋긴 한데, 반응형 디자인 지원되지 않음(각 기기마다 만족하는 최적값을 일일히 찾아야 함
            예 :10.5 ,10.4 ,10.3, ...... 10.01, ......10.08, 10.05,..10.05!)
                    
            ㅡ> 이 문제를 해결할 수 있는게 flex
          -->


          <!-- 
            vh = viewport height  viewport = screen  100vh = 100% 높이

            inline block의 문제점을 해결하기 위해 flexblock를 생각해냈다.
            flexbox 사용 규칙
            1. 자식 엘리먼트에는 어떤 것도 적지 말아야 함.
            자식 엘리먼트를 움직이게 하려면 부모 엘리먼트를 flex container로 만들어야 한다.
            2. align-items : cross axis에서 작용 (세로)
            3. justify-content : main axis에서 작용 (가로) (디폴트)
            flex-container가 height를 가지고 있지 않으면 align-items를 사용하더라도 위치가 바뀌지 않음.
           -->

           <!-- 
             main axis, cross axis의 기본 값을 바꾸기 위해서는 flex-direction을 사용한다.
             flex-direction의 기본 값을 row이다.
             원하는 만큼 flex 컨테이너를 만들 수 있다.
             flex wrap 을 wrap로 설정하면 한 줄에 컨텐츠가 들어갈 수 있는 만큼만 보여주고 나머지는 다음 줄로 넘김.
             no wrap일 경우 크기를 줄여서라도 한 줄로 표시
            -->


            <!-- 
                position fixed를 이용하면 스크롤해도 항상 제자리에 머무른다.
                처음 만들어진 자리에 고정 되어있다. 하지만 top, left, right, bottom 중 하나만 수정해도 서로 다른 레이어에 위치하게되어 원래 위치가 무시된다.
                positon fixed를 이용하면 가장 위에 위치하게 된다. (맨 앞)
             -->


             <!-- 
                 1. positon: static (default)
                 2. position: fixed
                 - element가 처음 생성된 자리에 고정.
                 3. position: relative;
                 - element가 '처음 생성된 위치'를 기준점으로, top bottom left right으로 위치를 조금씩 수정할 수 있다.
                 4. position: absolute;
                 가장 가까운 relative 부모를 기준으로 이동
                 position:relative; 를 해주면 부모가 된다.
                 없으면 body.
              -->

              <!-- 
                pseudo selector
                좀더 세부적으로 엘리먼트를 선택해 주는 것!
                (기존 방법 : 태그, id w/#, class w/.)

                선택의 복잡한 과정을 pseudo selector로 가능함
                ex>
                div:first-child {
                background-color: tomato;
                }

                /* pseudo selector */
                div:last-child {
                background-color: teal;
                }
                id나 class를 따로 만드는것보다 이렇게 지정하는게 훨씬 좋은 방법이다.
                css에서만 선택을 하면 되니까! html코드를 고칠 필요가 없기 때문이다

                n번째 태그 수정하기 nth-child(n) 올ㅋ
                span:nth-child(2) {
                background-color: teal;
                }
                span:nth-child(even) { //or odd ( 홀수 )
                background-color: teal;
                }

                even은 짝수! 짝수번째를 모두 바꿀 수있다 오 so cool !


                span:nth-child(5n + 1) {
                background-color: silver;
                }
                n을 사용하면 매우 편하다
               -->

               <!-- 
                div의 바로 밑 자식에서 span을 찾아서 그것만 효과를 주는 방법
                1)
                div span {
                text-decoration : underline;
                }
                이렇게하면 div밑에 있는 모든 span이 효과를 가진다
                직접적인 부모가 아니어도 밑에있는 것들을 모두 css가 찾는다.
                
                2) div > span {
                text-decoration : underline;
                }
                이렇게하면 바로 밑!!! 을 찾게 되므로 바로 밑의 자식만 건들일수있게된다.
                
                형제에게 효과를 주는방법
                
                p + span {
                color: black;
                
                }
                + 를 사용하면 형제에게 영향을 끼칠 수 있다. cool
                
                
                ※ > 를 사용하면 direct child를 찾고, + 를 사용하면 바로 코드상 밑에 있는 sibling을 찾게된다.
                -->
</body>
</html>